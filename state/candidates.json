{
  "active_edge": "Cycle 31: Prove residueMapFromR_surjective (R → valuationRingAt.residueField is surjective)",
  "cycle_30_results": {
    "goal": "Construct residueFieldBridge via bypass strategy",
    "status": "PROGRESS",
    "proved_count": 3,
    "sorry_count": 3,
    "candidates": [
      {
        "name": "embeddingToValuationRingAt",
        "type": "DEF",
        "status": "PROVED",
        "score": "3/5",
        "notes": "Ring hom R →+* valuationRingAt v"
      },
      {
        "name": "maximalIdeal_valuationRingAt_comap",
        "type": "PROVE",
        "status": "PROVED",
        "score": "4/5",
        "notes": "KEY: maximalIdeal ∩ R = v.asIdeal. Uses Valuation.mem_maximalIdeal_iff"
      },
      {
        "name": "residueMapFromR",
        "type": "DEF",
        "status": "OK",
        "score": "3/5",
        "notes": "Definition: R → valuationRingAt.residueField via embedding + residue"
      },
      {
        "name": "residueMapFromR_ker",
        "type": "PROVE",
        "status": "PROVED",
        "score": "4/5",
        "notes": "KEY: ker(residueMapFromR) = v.asIdeal. Enables First Isomorphism Theorem."
      },
      {
        "name": "residueMapFromR_surjective",
        "type": "PROVE",
        "status": "SORRY",
        "score": "5/5",
        "notes": "BLOCKER: Needs density argument - R is dense in valuationRingAt v for Dedekind domains"
      },
      {
        "name": "residueFieldBridge_v2",
        "type": "DEF",
        "status": "SORRY",
        "score": "5/5",
        "notes": "BLOCKED: Depends on residueMapFromR_surjective"
      },
      {
        "name": "residueFieldBridge_v3",
        "type": "DEF",
        "status": "SORRY",
        "score": "5/5",
        "notes": "BLOCKED: Depends on residueFieldBridge_v2"
      }
    ],
    "key_insight": "Bypass strategy works! The bridge construction is: (1) Show ker(residueMapFromR) = v.asIdeal (DONE), (2) Show residueMapFromR is surjective (BLOCKER), (3) Apply First Isomorphism Theorem. The surjectivity requires showing R is 'dense' in the valuation ring modulo maximal ideal."
  },
  "cycle_31_plan": {
    "goal": "Complete residueFieldBridge and evaluationMapAt",
    "tasks": [
      "Prove residueMapFromR_surjective using Dedekind domain properties",
      "Complete residueFieldBridge_v2 and v3",
      "Complete evaluationMapAt using bridge",
      "Prove kernel_evaluationMapAt",
      "Complete instLocalGapBound"
    ],
    "approach": "The surjectivity of R → residueField should follow from: for Dedekind domains, every element of the localization at a prime can be written as r/s where s ∉ v. When v(g) ≤ 1, we need to find r ∈ R with g - algebraMap R K r in maximal ideal.",
    "key_lemmas_needed": [
      "residueMapFromR_surjective: surjectivity of R → residue field",
      "Maybe: HeightOneSpectrum.mem_integers_of_valuation_le_one"
    ]
  },
  "architecture": {
    "hierarchy": [
      "LocalGapBound R K          -- TARGET: needs evaluationMapAt",
      "    ↑ extends",
      "SinglePointBound R K       -- PROJECTIVE (adds ell_zero = 1)",
      "",
      "BaseDim R K                -- SEPARATE (explicit base dimension)"
    ],
    "key_bridge": "local_gap_bound_of_exists_map connects evaluation map to typeclass",
    "residue_bridge_chain": [
      "R →+* valuationRingAt v (embeddingToValuationRingAt)",
      "valuationRingAt v →+* valuationRingAt.residueField v (IsLocalRing.residue)",
      "Compose: residueMapFromR : R →+* valuationRingAt.residueField v",
      "ker(residueMapFromR) = v.asIdeal (PROVED)",
      "surjective ⟹ valuationRingAt.residueField v ≃+* R/v.asIdeal (First Isomorphism Thm)",
      "R/v.asIdeal ≃+* residueFieldAtPrime R v (mathlib)"
    ]
  },
  "remaining_sorries": {
    "active": [
      {
        "name": "residueMapFromR_surjective",
        "line": 1414,
        "status": "BLOCKER",
        "notes": "KEY: Needs Dedekind domain density argument"
      },
      {
        "name": "residueFieldBridge_v2",
        "line": 1436,
        "status": "BLOCKED",
        "notes": "Depends on residueMapFromR_surjective"
      },
      {
        "name": "residueFieldBridge_v3",
        "line": 1449,
        "status": "BLOCKED",
        "notes": "Depends on residueFieldBridge_v2"
      },
      {
        "name": "residueFieldBridge (original)",
        "line": 1315,
        "status": "SUPERSEDED",
        "notes": "Use residueFieldBridge_v3 instead"
      },
      {
        "name": "evaluationMapAt",
        "line": 1029,
        "status": "BLOCKED",
        "notes": "Depends on residueFieldBridge"
      },
      {
        "name": "kernel_evaluationMapAt",
        "line": 1040,
        "status": "BLOCKED",
        "notes": "Depends on evaluationMapAt"
      },
      {
        "name": "instLocalGapBound",
        "line": 1049,
        "status": "BLOCKED",
        "notes": "Depends on kernel proof"
      }
    ],
    "resolved_cycle_30": [
      {
        "name": "maximalIdeal_valuationRingAt_comap",
        "line": 1374,
        "notes": "PROVED: maximal ideal pullback = v.asIdeal"
      },
      {
        "name": "residueMapFromR_ker",
        "line": 1397,
        "notes": "PROVED: ker = v.asIdeal"
      }
    ],
    "deprecated": [
      {
        "name": "ellV2_mono",
        "line": 335,
        "notes": "Superseded by ellV2_real_mono"
      },
      {
        "name": "riemann_inequality",
        "line": 713,
        "notes": "Superseded by riemann_inequality_real"
      }
    ]
  }
}
