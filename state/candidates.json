{
  "active_edge": "Cycle 21: Prove riemann_inequality using ellV2_real_mono + single-point bound",
  "candidates": [
    {
      "name": "Divisor α",
      "status": "PROVED",
      "statement": "abbrev Divisor (α : Type*) := α →₀ ℤ",
      "approach": "Type alias for Finsupp",
      "cycle": 4
    },
    {
      "name": "Divisor.deg",
      "status": "PROVED",
      "statement": "def deg (D : Divisor α) : ℤ := D.sum (fun _ n => n)",
      "approach": "Sum of coefficients",
      "cycle": 4
    },
    {
      "name": "Divisor.deg_add",
      "status": "PROVED",
      "statement": "deg (D + E) = deg D + deg E",
      "approach": "Via Finsupp.sum_add_index'",
      "cycle": 4
    },
    {
      "name": "Divisor.deg_zero",
      "status": "PROVED",
      "statement": "deg 0 = 0",
      "approach": "Via Finsupp.sum_zero_index",
      "cycle": 4
    },
    {
      "name": "Divisor.deg_neg",
      "status": "PROVED",
      "statement": "deg (-D) = -deg D",
      "approach": "Derived from deg_add + omega",
      "cycle": 4
    },
    {
      "name": "Divisor.deg_sub",
      "status": "PROVED",
      "statement": "deg (D - E) = deg D - deg E",
      "approach": "Derived from deg_add + deg_neg",
      "cycle": 4
    },
    {
      "name": "Divisor.deg_single",
      "status": "PROVED",
      "statement": "deg (single p n) = n",
      "approach": "Via Finsupp.sum_single_index",
      "cycle": 4
    },
    {
      "name": "Divisor.Effective",
      "status": "PROVED",
      "statement": "def Effective (D : Divisor α) : Prop := 0 ≤ D",
      "approach": "Uses mathlib's Finsupp pointwise order",
      "cycle": 5
    },
    {
      "name": "FunctionFieldData",
      "status": "DEFINED",
      "statement": "structure FunctionFieldData (α : Type*) with K, div, div_mul, div_one, div_inv, deg_div",
      "approach": "Axiomatizes function field with principal divisor map",
      "cycle": 5
    },
    {
      "name": "RRSpace (Submodule)",
      "status": "DEFINED",
      "statement": "def RRSpace (data : FunctionFieldData α k) (D : Divisor α) : Submodule k data.K",
      "approach": "Full k-submodule structure with zero_mem', add_mem', smul_mem'",
      "cycle": 6
    },
    {
      "name": "ell",
      "status": "DEFINED",
      "statement": "def ell (data : FunctionFieldData α k) (D : Divisor α) := Module.finrank k (RRSpace data D)",
      "approach": "Semantic dimension using mathlib's finrank",
      "cycle": 7
    },
    {
      "name": "FunctionFieldDataWithBound",
      "status": "DEFINED",
      "statement": "structure extending FunctionFieldData with single_point_bound : ∀ D p, ell (D + p) ≤ ell D + 1",
      "approach": "Axiomatize single-point dimension bound",
      "cycle": 10
    },
    {
      "name": "ell.le_deg_add_ell_zero_from_bound",
      "status": "PROVED",
      "statement": "Effective D → (ell data D : ℤ) ≤ deg D + ell data 0",
      "approach": "RIEMANN INEQUALITY - degree induction",
      "cycle": 11
    },
    {
      "name": "FunctionFieldDataWithRR",
      "status": "DEFINED",
      "statement": "structure extending FunctionFieldDataWithBound with genus, K_div, deg_K, rr_axiom",
      "approach": "Axiomatize full Riemann-Roch as structure fields",
      "cycle": 12
    },
    {
      "name": "FunctionFieldDataWithRR.riemannRoch_eq",
      "status": "PROVED",
      "statement": "ℓ(D) - ℓ(K-D) = deg D + 1 - g",
      "approach": "Direct application of rr_axiom",
      "cycle": 12
    },
    {
      "name": "FunctionFieldDataWithRR.ell_K",
      "status": "PROVED",
      "statement": "ℓ(K) = g",
      "approach": "Apply RR to D = K, use ℓ(0) = 1 and deg(K) = 2g-2",
      "cycle": 12
    },
    {
      "name": "FunctionFieldDataWithRR.ell_K_sub_D_eq_zero_of_deg_gt",
      "status": "PROVED",
      "statement": "deg D > 2g - 2 → ℓ(K-D) = 0",
      "approach": "Vanishing via deg_div semantic content",
      "cycle": 12
    },
    {
      "name": "FunctionFieldDataWithMul.clifford_bound'",
      "status": "PROVED",
      "statement": "ℓ(D) ≥ 2 → ℓ(K-D) ≥ 2 → 2·ℓ(D) ≤ deg D + 2",
      "approach": "Clifford's theorem via multiplication axiom",
      "cycle": 16
    }
  ],
  "cycle_20_candidates": [
    {
      "name": "ellV2_real_extended",
      "status": "DEFINED",
      "statement": "noncomputable def ellV2_real_extended (D : DivisorV2 R) : ℕ∞ := Module.length R (RRModuleV2_real R K D)",
      "approach": "Module.length on valuation-based L(D), returns ℕ∞",
      "score": 5,
      "cycle": 20
    },
    {
      "name": "ellV2_real",
      "status": "DEFINED",
      "statement": "noncomputable def ellV2_real (D : DivisorV2 R) : ℕ := (ellV2_real_extended R K D).toNat",
      "approach": "Natural number extraction via toNat",
      "score": 5,
      "cycle": 20
    },
    {
      "name": "ellV2_real_mono_extended",
      "status": "PROVED",
      "statement": "D ≤ E → ellV2_real_extended R K D ≤ ellV2_real_extended R K E",
      "approach": "RRModuleV2_mono_inclusion + Submodule.inclusion_injective + Module.length_le_of_injective",
      "score": 5,
      "cycle": 20
    },
    {
      "name": "ellV2_real_mono",
      "status": "PROVED",
      "statement": "D ≤ E → (finiteness) → ellV2_real R K D ≤ ellV2_real R K E",
      "approach": "ellV2_real_mono_extended + ENat.toNat_le_toNat with finiteness hypothesis",
      "score": 5,
      "cycle": 20
    },
    {
      "name": "ellV2_real_mono'",
      "status": "PROVED",
      "statement": "D ≤ E → (ellV2_real R K D ≤ ellV2_real R K E) ∨ (ellV2_real_extended R K E = ⊤)",
      "approach": "Alternative formulation covering infinite case",
      "score": 4,
      "cycle": 20
    }
  ],
  "cycle_19_candidates": [
    {
      "name": "satisfiesValuationCondition (FIXED)",
      "status": "PROVED",
      "statement": "def satisfiesValuationCondition (D) (f) := f = 0 ∨ ∀ v, v.valuation K f ≤ exp(D v)",
      "approach": "BUG FIX: Changed from ≥ exp(-D) to ≤ exp(D) - correct membership direction",
      "score": 5,
      "cycle": 19
    },
    {
      "name": "RRModuleV2_real.add_mem'",
      "status": "PROVED",
      "statement": "a ∈ L(D) → b ∈ L(D) → a + b ∈ L(D)",
      "approach": "Valuation.map_add_le_max' + max_le",
      "score": 5,
      "cycle": 19
    },
    {
      "name": "RRModuleV2_real.smul_mem'",
      "status": "PROVED",
      "statement": "f ∈ L(D) → r • f ∈ L(D) for r ∈ R",
      "approach": "valuation_le_one + mul_le_mul' + one_mul",
      "score": 5,
      "cycle": 19
    },
    {
      "name": "RRModuleV2_mono_inclusion (updated)",
      "status": "PROVED",
      "statement": "D ≤ E → RRModuleV2_real R K D ≤ RRModuleV2_real R K E",
      "approach": "Updated for corrected membership direction",
      "score": 5,
      "cycle": 19
    }
  ],
  "blockers": [
    "mathlib lacks: line bundles, sheaf cohomology H⁰/H¹, genus for schemes",
    "Base RRData.riemannRoch has no proof path without additional structure axioms",
    "riemann_inequality needs single-point bound axiom or evaluation map construction"
  ],
  "resolved_blockers": [
    "CYCLE 4-6: Divisor foundations, FunctionFieldData, RRSpace as k-Submodule",
    "CYCLE 7-8: ell(D) = finrank, finite-dimensionality via typeclass",
    "CYCLE 9: Quotient infrastructure for dimension bounds",
    "CYCLE 10: FunctionFieldDataWithBound axiom extension",
    "CYCLE 11: Riemann inequality PROVED via degree induction",
    "CYCLE 12: Full FunctionFieldDataWithRR structure, 7 lemmas PROVED",
    "CYCLE 13: Cleanup - removed 4 superseded sorries",
    "CYCLE 14: Genus 0 special cases - 7 lemmas PROVED",
    "CYCLE 15: Genus 1 / Elliptic curves - 6 lemmas PROVED",
    "CYCLE 16: Clifford's theorem PROVED via multiplication axiom",
    "CYCLE 17: RR_v2.lean created - Dedekind domain foundations",
    "CYCLE 18: Valuation-based L(D) defined, RRModuleV2_mono_inclusion PROVED",
    "CYCLE 19: RRModuleV2_real COMPLETE - bug fix + add_mem'/smul_mem' PROVED",
    "CYCLE 20: ellV2_real_mono PROVED - Module.length_le_of_injective + Submodule.inclusion"
  ],
  "next_action": "Cycle 21: Add single-point bound axiom, prove riemann_inequality using ellV2_real"
}
