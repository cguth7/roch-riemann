{
  "active_edge": "Cycle 23: Resolve affine vs projective model - decide dimension approach",
  "candidates": [
    {
      "name": "Divisor α",
      "status": "PROVED",
      "statement": "abbrev Divisor (α : Type*) := α →₀ ℤ",
      "approach": "Type alias for Finsupp",
      "cycle": 4
    },
    {
      "name": "Divisor.deg",
      "status": "PROVED",
      "statement": "def deg (D : Divisor α) : ℤ := D.sum (fun _ n => n)",
      "approach": "Sum of coefficients",
      "cycle": 4
    },
    {
      "name": "ell.le_deg_add_ell_zero_from_bound",
      "status": "PROVED",
      "statement": "Effective D → (ell data D : ℤ) ≤ deg D + ell data 0",
      "approach": "RIEMANN INEQUALITY - degree induction",
      "cycle": 11
    },
    {
      "name": "FunctionFieldDataWithRR.riemannRoch_eq",
      "status": "PROVED",
      "statement": "ℓ(D) - ℓ(K-D) = deg D + 1 - g",
      "approach": "Direct application of rr_axiom",
      "cycle": 12
    },
    {
      "name": "FunctionFieldDataWithMul.clifford_bound'",
      "status": "PROVED",
      "statement": "ℓ(D) ≥ 2 → ℓ(K-D) ≥ 2 → 2·ℓ(D) ≤ deg D + 2",
      "approach": "Clifford's theorem via multiplication axiom",
      "cycle": 16
    }
  ],
  "cycle_22_candidates": [
    {
      "name": "residueFieldAtPrime",
      "status": "OK",
      "statement": "noncomputable abbrev residueFieldAtPrime (v : HeightOneSpectrum R) : Type _ := v.asIdeal.ResidueField",
      "approach": "Residue field κ(v) at height-1 prime",
      "score": 5,
      "cycle": 22
    },
    {
      "name": "residueFieldAtPrime.field",
      "status": "OK",
      "statement": "noncomputable instance residueFieldAtPrime.field (v) : Field (residueFieldAtPrime R v) := inferInstance",
      "approach": "Field instance automatic from mathlib",
      "score": 5,
      "cycle": 22
    },
    {
      "name": "residueMapAtPrime",
      "status": "OK",
      "statement": "noncomputable def residueMapAtPrime (v) : R →+* residueFieldAtPrime R v := algebraMap R _",
      "approach": "Residue map R → κ(v)",
      "score": 5,
      "cycle": 22
    },
    {
      "name": "RRModuleV2_real_zero_eq_R",
      "status": "BLOCKED",
      "statement": "(RRModuleV2_real R K 0).carrier = Set.range (algebraMap R K)",
      "approach": "L(0) = R (global-local principle)",
      "blocker": "Needs IsDedekindDomain.eq_of_localization_eq_localization adaptation",
      "score": 2,
      "cycle": 22
    },
    {
      "name": "ell_zero_eq_one",
      "status": "IMPOSSIBLE",
      "statement": "ellV2_real R K 0 = 1",
      "approach": "L(0) = 1-dimensional",
      "blocker": "FUNDAMENTAL FLAW: L(0) = R (infinite-dimensional), NOT k. Model captures only FINITE places.",
      "score": 0,
      "cycle": 22
    },
    {
      "name": "uniformizerAt",
      "status": "BLOCKED",
      "statement": "noncomputable def uniformizerAt (v) : Localization.AtPrime v.asIdeal",
      "approach": "Extract uniformizer from DVR",
      "blocker": "mathlib DVR API limited for uniformizer extraction",
      "score": 2,
      "cycle": 22
    },
    {
      "name": "evaluationMap",
      "status": "BLOCKED",
      "statement": "noncomputable def evaluationMap (D) (v) : RRModuleV2_real R K (D + v) →ₗ[R] residueFieldAtPrime R v",
      "approach": "Evaluation via uniformizer multiplication",
      "blocker": "Depends on uniformizerAt",
      "score": 2,
      "cycle": 22
    },
    {
      "name": "SinglePointBound instance",
      "status": "BLOCKED",
      "statement": "instance : SinglePointBound R K",
      "approach": "Via evaluationMap kernel bound",
      "blocker": "Depends on evaluationMap AND ell_zero_eq_one (impossible)",
      "score": 0,
      "cycle": 22
    }
  ],
  "cycle_21_candidates": [
    {
      "name": "SinglePointBound",
      "status": "DEFINED",
      "statement": "class SinglePointBound with bound : ℓ(D+v) ≤ ℓ(D)+1, ell_zero_eq_one : ℓ(0) = 1",
      "approach": "Typeclass encapsulating single-point bound axioms",
      "score": 5,
      "cycle": 21
    },
    {
      "name": "riemann_inequality_real",
      "status": "PROVED",
      "statement": "[SinglePointBound R K] → Effective D → (ℓ(D) : ℤ) ≤ deg(D) + 1",
      "approach": "Degree induction on (deg D).toNat - KEY THEOREM",
      "score": 5,
      "cycle": 21
    }
  ],
  "blockers": [
    "mathlib lacks: line bundles, sheaf cohomology H⁰/H¹, genus for schemes",
    "CRITICAL (Cycle 22): HeightOneSpectrum captures only FINITE places - L(0) = R not k",
    "SinglePointBound.ell_zero_eq_one is UNPROVABLE in current affine model"
  ],
  "resolved_blockers": [
    "CYCLE 4-6: Divisor foundations, FunctionFieldData, RRSpace as k-Submodule",
    "CYCLE 7-8: ell(D) = finrank, finite-dimensionality via typeclass",
    "CYCLE 9: Quotient infrastructure for dimension bounds",
    "CYCLE 10: FunctionFieldDataWithBound axiom extension",
    "CYCLE 11: Riemann inequality PROVED via degree induction",
    "CYCLE 12: Full FunctionFieldDataWithRR structure, 7 lemmas PROVED",
    "CYCLE 13: Cleanup - removed 4 superseded sorries",
    "CYCLE 14: Genus 0 special cases - 7 lemmas PROVED",
    "CYCLE 15: Genus 1 / Elliptic curves - 6 lemmas PROVED",
    "CYCLE 16: Clifford's theorem PROVED via multiplication axiom",
    "CYCLE 17: RR_v2.lean created - Dedekind domain foundations",
    "CYCLE 18: Valuation-based L(D) defined, RRModuleV2_mono_inclusion PROVED",
    "CYCLE 19: RRModuleV2_real COMPLETE - bug fix + add_mem'/smul_mem' PROVED",
    "CYCLE 20: ellV2_real_mono PROVED - Module.length_le_of_injective + Submodule.inclusion",
    "CYCLE 21: SinglePointBound typeclass + riemann_inequality_real PROVED - 8/8 candidates",
    "CYCLE 22: Residue field infrastructure merged (3/8), CRITICAL DISCOVERY: affine model limitation"
  ],
  "next_action": "Cycle 23: Decide approach for dimension definition (relative vs compactification vs accept affine)"
}
