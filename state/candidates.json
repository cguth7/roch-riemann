{
  "active_edge": "Cycle 25: Construct evaluation map and prove LocalGapBound instance",
  "cycle_24_phase2_results": {
    "goal": "Uniformizer infrastructure and shifted valuation lemma",
    "status": "COMPLETE",
    "proved_count": 7,
    "sorry_count": 4,
    "candidates": [
      {
        "name": "uniformizerAt",
        "type": "DEFINE",
        "status": "DEFINED",
        "score": "5/5",
        "notes": "Classical.choose from intValuation_exists_uniformizer"
      },
      {
        "name": "uniformizerAt_val",
        "type": "PROVE",
        "status": "PROVED",
        "score": "5/5",
        "notes": "v.intValuation π = exp(-1)"
      },
      {
        "name": "uniformizerAt_ne_zero",
        "type": "PROVE",
        "status": "PROVED",
        "score": "5/5",
        "notes": "π ≠ 0 via cases on impossible eq"
      },
      {
        "name": "uniformizerAt_pow_val",
        "type": "PROVE",
        "status": "PROVED",
        "score": "5/5",
        "notes": "Uses WithZero.exp_nsmul"
      },
      {
        "name": "uniformizerAt_valuation",
        "type": "PROVE",
        "status": "PROVED",
        "score": "5/5",
        "notes": "Bridge to K via valuation_of_algebraMap"
      },
      {
        "name": "uniformizerAt_pow_valuation",
        "type": "PROVE",
        "status": "PROVED",
        "score": "5/5",
        "notes": "Powers extend to K correctly"
      },
      {
        "name": "shifted_element_valuation_le_one",
        "type": "PROVE",
        "status": "PROVED",
        "score": "5/5",
        "notes": "KEY RESULT - full valuation arithmetic proof"
      },
      {
        "name": "evaluationMapAt_prototype",
        "type": "DEFINE",
        "status": "SORRY",
        "score": "2/5",
        "notes": "Cycle 25 target - needs localization approach"
      },
      {
        "name": "kernel_evaluationMapAt",
        "type": "PROVE",
        "status": "SORRY",
        "score": "2/5",
        "notes": "Cycle 25 target - depends on φ construction"
      },
      {
        "name": "instLocalGapBound",
        "type": "INSTANCE",
        "status": "SORRY",
        "score": "3/5",
        "notes": "Cycle 25 victory condition"
      }
    ]
  },
  "cycle_25_plan": {
    "goal": "Complete LocalGapBound instance",
    "tasks": [
      "Construct evaluationMapAt : L(D+v) →ₗ[R] κ(v) using shifted evaluation",
      "Prove kernel condition: ker(evaluationMapAt) = range(inclusion)",
      "Apply local_gap_bound_of_exists_map to get LocalGapBound instance",
      "Victory: riemann_inequality_affine becomes unconditional"
    ],
    "approach": "Use localization at v.asIdeal - shifted element is in valuation ring, maps to κ(v)",
    "key_lemmas_available": [
      "shifted_element_valuation_le_one (PROVED)",
      "local_gap_bound_of_exists_map (PROVED)",
      "residueFieldAtPrime.isSimpleModule (PROVED)",
      "residueFieldAtPrime.length_eq_one (PROVED)"
    ]
  },
  "architecture": {
    "hierarchy": [
      "LocalGapBound R K          -- TARGET: Cycle 25 (gap ≤ 1 via evaluation map)",
      "    ↑ extends",
      "SinglePointBound R K       -- PROJECTIVE (adds ell_zero = 1)",
      "",
      "BaseDim R K                -- SEPARATE (explicit base dimension)"
    ],
    "key_bridge": "local_gap_bound_of_exists_map connects evaluation map to typeclass"
  }
}
